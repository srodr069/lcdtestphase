/*
  purpose: converts a pnm file to C source code for 12/16/18 Bit ILI9163 displays

  author: Henryk Richter <buggs@comlab.uni-rostock.de>

  license: GPL V2

  compilation: gcc -o pnm2ILI9163 pnm2ILI9163.c

  syntax: pnm2ILI9163 <infile> <outfile> [-dither n] [-indexed] [-flcm]

  inputs:     - binary PNM/PPM files (types P5,P6, 8 Bit only for the latter two)
         _OR_ - uncompressed BMP 8/16/24/32 Bit (Windows or OS/2 1.x style)
          optional: -dither <num>, where <num> is 0...5
                    -indexed = output indexed pixels (8 bit per pixel) plus color map
		               (currently requires 8 Bit BMPs as input, no color quantizer in here)

  output: 
   - C-formatted file, dimensions of image as comment 
   - outputs 12/16/18 bit images, with #ifdef decision by _LCD_12BIT/_LCD_16BIT directives
   - output of 8 bit indexed images (when using BMP inputs)

  notes:
   - the ILI9163 displays have varying sizes
   - in 8 Bit mode, each byte corresponds to 1 pixel (special palette based mode of my driver)
   - in 12 Bit mode, three bytes correspond to 2 pixels
   - in 16 Bit mode, each pixel spans two bytes
   - in 18 Bit mode, the transfer size is actually 24 Bit per pixel, 
     resulting in quite large bitmaps
   - conversion is easy, just round+shift from 8 Bit inputs
     - dithering makes this process a little more complicated but still
       straightforward by today's standards

   data organization:
   - row by row, starting with the upleft corner

   version history:
   - 0.4 cleanup
   - 0.3 implemented color map from first line of input image, i.e. take the first row and
         export the pixel values as RGB() statements, I had serious difficulties forcing the
	 usual programs to maintain a specific colormap - hence this alternative (-flcm) 
   - 0.2 implemented uncompressed BMP support, either for dithering using the normal color
         path or to be used for 8 bit indexed color (chunky pixels, no packing yet)
   - 0.1 initial log
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define BAILOUT(a) { fclose(in);fclose(out);printf(a);exit(0); }
#define minmax(mi,ma,val) ((val) < (mi)) ? (mi) : ((val) > (ma)) ? (ma) : (val)
/* DEBUG: write a PNM of the dithered result */
#define DBG

//#define MONO_DIFF    /* monochrome diffusion error calculation ? (switch to "by channel" diffusion by removing this define) */
#define DIFF_SHIFT 5 /* pixel level shift left to accomodate error diffusion with higher accuracy */
	/* Burkes */
#define burkes_num 7
int    burkes[7*3] = {
		4, 1,0,
		2, 2,0,
		1,-2,1,
		2,-1,1,
		4, 0,1,
		2, 1,1,
		1, 2,1,
	};
	/* FLOYD-Steinberg */
#define floydstein_num 4
	int    floydstein_pat[4*3] = {
		7, 1,0 ,
		3,-1,1 ,
		5, 0,1 ,
		1, 1,1 ,
	};
	/* Atkinson */
#define atkins_num 6
	int    atkins_pat[6*3] = {
		2, 1,0 ,
		2,-1,1 ,
		2, 0,1 ,
		2, 1,1 ,
		2, 0,2 ,
		2, 2,0 ,
	};
	/* 2x2 ordered */
	double dx2[2*2]={1./5.,3./5.,
			 4./5.,2./5.};
	/* 4x4 ordered */
	double dx4[4*4] =
	{
        	 1./17., 9./17., 3./17.,11./17.,
        	13./17., 5./17.,15./17., 7./17.,
        	 4./17.,12./17., 2./17.,10./17.,
        	16./17., 8./17.,14./17., 6./17.,
	};
	double dx1[1*1] = { 0.5 }; // fake ordered

	int shifts[4][5] = {
		{ 4,4,4,3,12 }, /* 12 (shift r,g,b; bytes per 2 pixels, depth )*/
		{ 3,2,3,4,16 }, /* 16 565 */
		{ 2,2,2,6,18 }, /* 18 */
		{ 0,0,0,2,8  }, /* 8 Bit indexed */
	};
	char *defs[4][2] = {
		{ "#ifdef _LCD_12BIT", "#else" },
		{ "#ifdef _LCD_16BIT", "#else" },
		{ " ", "#endif\n#endif" },
		{ " ", " " },
	};
	int flcm=0; /* hups, this one is global */

/*---------------- convert input pixmap (8 Bit Gray) to Nokia 5110 -------------*/
int img2siemens( short *inbuf, long w, long h, long dither, FILE *out, unsigned char *palette, int np ) // contents of buf are * 2 (!)
{ /* input buffer: RGB24 */
	int i,j,mw,mh,run,srun,maxrun;
	int idx,bestidx,dist,tmp;
	unsigned int o,c,pc;
	short *bp;
	double r,g,b;
	int k,l,m;
#ifdef DBG
	FILE *dbg;
	char tmpname[30];
	unsigned char pix[3];
#endif
	int	floyd_num;
	int	*floyd_pat;

	int    fl,fx,fy;
	double r1,g1,b1;
	double *dx  = dx1;	/* no ordered dither */
	int    dmod = 1;           /* */

	short *buf = (short*)malloc( w*h*3*sizeof(short) );

	mw = w;
	mh = h;

	floyd_num = 0;
	floyd_pat = burkes;
	switch( dither )
	{
		case 1:
			floyd_num = floydstein_num;
			floyd_pat = floydstein_pat;
			break;
		case 2:
			floyd_num = burkes_num;
			floyd_pat = burkes;
			break;
		case 3:
			floyd_num = atkins_num;
			floyd_pat = atkins_pat;
			break;
		case 4:
			dx   = dx2;
			dmod = 2;
			break;
		case 5: dx   = dx4;
			dmod = 4;
			break;
		default:
			floyd_num = 0;
			floyd_pat = burkes;
			break;
	}

	fprintf(out,"/* File generated by pnm2ILI9163 for use with          */\n");
	fprintf(out,"/* ILI9163/ST7735 based displays                       */\n");
	fprintf(out,"/* http://bax.comlab.uni-rostock.de                    */\n");
	fprintf(out,"/*                                                     */\n\n");
	fprintf(out,"#ifndef PROGMEM\n#define PROGMEM\n#endif\n\n");
	fprintf(out,"#define IMG_WIDTH  %d\n",mw);
	fprintf(out,"#define IMG_HEIGHT %d\n",mh);
	fprintf(out,"#define IMG_PTR    %s\n\n","ili9163_image");

#define RSHIFT8 shifts[run][0]
#define GSHIFT8 shifts[run][1]
#define BSHIFT8 shifts[run][2]

	if( flcm )
	{
		buf = inbuf;
		fprintf(out,"/* Color Table: 8 Bit RGB from first image line        */\n\n");
		fprintf( out, "const color_t ili9163_flcmcolortab[%d] PROGMEM = {",mw);
		for( i=0 ; i<mw ; i++ )
		{
			if( !(i&3) )
				fprintf(out,"\n");

			fprintf(out,"LCD_RGB(%3d,%3d,%3d), ",buf[0]>>DIFF_SHIFT,buf[1]>>DIFF_SHIFT,buf[2]>>DIFF_SHIFT);
			buf+=3;
		}
		fprintf(out,"\n};\n");
	}

	o=0;
	srun   = 0;
	maxrun = 3;
	if( palette != NULL )
	{
		srun = 3;
		maxrun = 4;
		fprintf(out,"/* Color Table: 8 Bit RGB                              */\n\n");
		fprintf( out, "const color_t ili9163_colortab[%d] PROGMEM = {",np);
		for( idx=0 ; idx < np ; idx++ )
		{
			if( (idx&3)==0 ) 
				fprintf(out,"\n");

			fprintf(out,"LCD_RGB(%-3d,%-3d,%-3d), ",palette[(idx<<2)+2],palette[(idx<<2)+1],palette[(idx<<2)+0]);
		}
		fprintf(out,"\n};\n");
	}
	for( run = srun ; run < maxrun ; run++ ) /* run over bit depths */
	{
		memcpy( buf, inbuf, mw*mh*3*sizeof(short) );

		fprintf(out,"%s\n",defs[run][0]);
		fprintf(out,"/* ILI9163 %d bpp image width %d height %d */\n",shifts[run][4],mw,mh);
		fprintf( out, "const unsigned char PROGMEM ili9163_image[%d] = {\n",(mw*mh*shifts[run][3]+1)/2);
#ifdef DBG	
		sprintf(tmpname,"test_image%d.pnm",run);
		dbg = fopen(tmpname,"wb");
		fprintf(dbg,"P6\n%d %d\n255\n",mw,mh);
#endif
		pc=0; /* pixel counter */
		for( j = 0, c=0 ; j < mh ; j++ ) /* */ 
		{
			bp = buf + w*3*j;
			for( i=0 ; i < mw ; i++ )
			{
				/* lazy FP calculations */
				r1 =(double)(bp[0]);
				g1 =(double)(bp[1]);
				b1 =(double)(bp[2]);
				/* ordered dithering */
				r  = r1 + dx[(i % dmod)+ (j % dmod)* dmod ] * (double)(1<<(RSHIFT8+DIFF_SHIFT));
				g  = g1 + dx[(i % dmod)+ (j % dmod)* dmod ] * (double)(1<<(GSHIFT8+DIFF_SHIFT));
				b  = b1 + dx[(i % dmod)+ (j % dmod)* dmod ] * (double)(1<<(BSHIFT8+DIFF_SHIFT));

				/* color quantization */
				k   = ( minmax( 0., (double)(-1+(256<<DIFF_SHIFT)), r ) ); /* 2*256-1 */
				k >>= (RSHIFT8+DIFF_SHIFT);
				l   = ( minmax( 0., (double)(-1+(256<<DIFF_SHIFT)), g ) );
				l >>= (GSHIFT8+DIFF_SHIFT);
				m   = ( minmax( 0., (double)(-1+(256<<DIFF_SHIFT)), b ) );
				m >>= (BSHIFT8+DIFF_SHIFT);

				bestidx = 0;
				if( run == 3 ) /* indexed ? */
				{
					dist    = 0x7fffffff;
					for( idx=0 ; idx < np ; idx++ )
					{
						tmp = (k-palette[(idx<<2)+2])*(k-palette[(idx<<2)+2]);
						tmp+= (l-palette[(idx<<2)+1])*(l-palette[(idx<<2)+1]);
						tmp+= (m-palette[(idx<<2)+0])*(m-palette[(idx<<2)+0]);
						if( tmp < dist )
						{
							bestidx = idx;
							dist    = tmp;
						}
					}
					k = palette[(bestidx<<2)+2];
					l = palette[(bestidx<<2)+1];
					m = palette[(bestidx<<2)+0];
				}

				/* TODO: proper parameterization of output calculations */
				switch( run )
				{
					case 0:
						if( pc & 1 )
						{
							fprintf( out, "0x%02x,",(o<<4)|k );
							fprintf( out, "0x%02x,",(l<<4)|m );
						}
						else
						{
							fprintf( out, "0x%02x,",(k<<4)|l );
							o=m;
						}
						break;
					case 1:
						fprintf( out, "0x%02x,",(k<<3)+(l>>3));
						fprintf( out, "0x%02x,",((l<<5)+m)&0xff);
						break;
					case 2:
						/* 18 bit mode is actually RGB24 with lower bits = 0 */
						fprintf( out, "0x%02x,",k<<2);
						fprintf( out, "0x%02x,",l<<2);
						fprintf( out, "0x%02x,",m<<2);
						break;
					default: /* indexed mode */
						fprintf( out, "0x%02x,",bestidx);
						break;
				}
#ifdef DBG
				pix[0]=(k<<RSHIFT8);pix[1]=(l<<GSHIFT8);pix[2]=(m<<BSHIFT8);
				fwrite(pix,1,3,dbg);
#endif
#if 1
				/* error diffusion: distribute error */
				k <<= (RSHIFT8+DIFF_SHIFT);
				k  += (1<<(RSHIFT8+DIFF_SHIFT-1));
				l <<= (GSHIFT8+DIFF_SHIFT);
				l  += (1<<(GSHIFT8+DIFF_SHIFT-1));
				m <<= (BSHIFT8+DIFF_SHIFT);
				m  += (1<<(BSHIFT8+DIFF_SHIFT-1));
				k  -= bp[0];
				l  -= bp[1];
				m  -= bp[2];
#ifdef MONO_DIFF
				err = (k+l+l+m)/4; /* monochrome error calculation */
				k=l=m=err;
#endif
				//printf("%d %d %d %d %d %d\n",k,l,m,bp[0],bp[1],bp[2]);
				for( fl=0 ; fl < floyd_num ; fl++ )
				{
					fx = floyd_pat[fl*3+1] + i;
					fy = floyd_pat[fl*3+2] + j;
					if( (fx >= 0) && (fx < mw) && (fy>=0) && (fy< mh))
					{
						/* adaptive diffusion dithering: if target pixel vastly different from
						   current, do not transfer error */
						if( abs(bp[0] - bp[(fy-j)*w*3+(fx-i)*3+0]) < (64<<RSHIFT8) )
							bp[(fy-j)*w*3+(fx-i)*3+0] -= (k*floyd_pat[fl*3+0]) >> 4;
						if( abs(bp[1] - bp[(fy-j)*w*3+(fx-i)*3+1]) < (64<<GSHIFT8) )
							bp[(fy-j)*w*3+(fx-i)*3+1] -= (l*floyd_pat[fl*3+0]) >> 4;
						if( abs(bp[2] - bp[(fy-j)*w*3+(fx-i)*3+2]) < (64<<BSHIFT8) )
							bp[(fy-j)*w*3+(fx-i)*3+2] -= (m*floyd_pat[fl*3+0]) >> 4;
					}
				}
#endif
				c++;
				if( (c & (15>>((run>0)?1:0))) == 0 )
					fprintf( out,"\n");
				bp+=3;
				pc++;
			}
		}
		fprintf( out, "};\n");
		fprintf( out, "%s\n",defs[run][1]);
#ifdef DBG
		fclose(dbg);
#endif
	}
	return 0;
}

/* --------------- BMP structure */
struct bmpparse {
        unsigned int magic;
	int w;
	int h;
	int dy;
	int depth; /* 1,4,8,16,24,32 */
	int ncolors; /* number of entries in palette */
	int os2;
	long fsize;
	long offpix;
	FILE *infile;
	unsigned char *palette;
};
#define GETBMP16(b,o) (b)[o]+((b)[(o)+1]<<8)
#define GETBMP32(b,o) (b)[o]+((b)[(o)+1]<<8)+((b)[(o)+2]<<16)+((b)[(o)+3]<<24)

int BMP_Parse( FILE *infile, struct bmpparse *bmp )
{
	unsigned char buffer[100]; /* just used for parsing */
	long a;

	bmp->magic = 0; /* not initialized */
	fseek( infile, 0, SEEK_SET );
	fread( buffer, 1, 54, infile); /* BMP header */
	if( (buffer[0] != 'B') || (buffer[1] != 'M' ) )
		return -1; /* NOT BMP */
	a = GETBMP32( buffer, 0x0E ); /* size field, is 14 for OS/2 style BMPs */
	bmp->fsize  = GETBMP32( buffer, 0x2 );
	bmp->offpix = GETBMP32( buffer, 0xA );
	if( a == 12 )
	{
		//printf("OS/2 BMP detected, rudimentary support only\n");
		bmp->w      = GETBMP16( buffer, 0x12 );
		bmp->h      = abs( GETBMP16( buffer, 0x14 ) );
		bmp->dy     = GETBMP16( buffer, 0x14 ); /* vertically forward / backward stored */
		bmp->depth  = GETBMP16(buffer,0x18 );
		bmp->ncolors= 0;
		bmp->os2    = 1;
	}
	else
	{
		a = GETBMP32( buffer, 0x1E ); /* compression */
		if( a )
		{
			printf("sorry, compressed BMPs are not supported\n");
			return -1; /* compression unsupported (RLE is easy btw.) */
		}
		/* parameters */
		bmp->w      = GETBMP32( buffer, 0x12 );
		bmp->h      = abs( GETBMP32( buffer, 0x16 ) );
		bmp->dy     = GETBMP32( buffer, 0x16 ); /* vertically forward / backward stored */
		bmp->depth  = GETBMP16(buffer,0x1C );
		bmp->ncolors= GETBMP32(buffer,0x2E);
		bmp->os2    = 0;
	}
	bmp->palette = NULL;
	bmp->magic = 0xDEADBEEF;
	bmp->infile = infile;

	//printf("w %d, h %d d %d nc %d\n",bmp->w,bmp->h,bmp->depth,bmp->ncolors);

	return bmp->depth; /* >0 : success, report bit depth */
}

int BMP_GetCMAP( struct bmpparse *bmp )
{
	int i,nc = bmp->ncolors;

	if( bmp->palette )
		free( bmp->palette );

	if( bmp->depth >= 16 )
		return 0; /* not palette mode */
	
	if( !nc )
	{
		if( bmp->os2 )
			nc = (bmp->offpix - 14 - 12)/3;
		else
			nc = 1<<bmp->depth;
	}

	bmp->ncolors = nc;
	bmp->palette = (unsigned char *)malloc( 256*4 ); /* always room for unsigned char addressing */
	if( !bmp->palette )
		return -1;

	if( bmp->os2 )
	{
		fseek( bmp->infile, 14+12, SEEK_SET );
		for( i=0; i < nc ; i++ )
			fread( bmp->palette+4*i, 3, 1, bmp->infile );
	}
	else
	{

		fseek( bmp->infile, 54, SEEK_SET );
		fread( bmp->palette, 4, nc, bmp->infile); /* BMP color map */
	}
	return nc;
}
/*
  read BMP contents to supplied buffer, convert to given mode
  FIXME: - limited implementation
         - currently only mode 1 = RGB24 output supported
*/
int BMP_GetPix( struct bmpparse *bmp, short *buffer, int bufsize, int mode )
{
	int i,starty,stopy,stepy,nx,err=-4,b;
	unsigned char *p;
	unsigned char *tmpbuf;

	if( mode != 1 ) /* mode1 == convert to RGB24 */
		return -1; /* wrong mode */
	if( bufsize < (bmp->w*bmp->h*3) )
		return -2; /* buffer too small */
	starty = 0;
	stepy  = 1;
	stopy  = bmp->h;
	if( bmp->dy > 0 )
	{
		starty = bmp->h-1;
		stepy  = -1;
	}
	tmpbuf = (unsigned char*)malloc( bmp->w * 4 ); 
	
	{
	 int fileoffset = bmp->offpix-54-4*bmp->ncolors;
	 if( fileoffset <= 0 )
	 	fileoffset = 54+4*bmp->ncolors;
         fseek( bmp->infile, fileoffset, SEEK_SET );
	}

	switch( bmp->depth )
	{
		//case 1:
		//case 4:
		case 8:
			if( !bmp->palette )
				BMP_GetCMAP( bmp );
			if( !bmp->palette )
				goto bailout;
			nx = (bmp->w + 3) & (~3); /* round up to multiple of 4 bytes per line */
			while( stopy-- )
			{
				fread( tmpbuf, 1, nx, bmp->infile );
				for( i=0 ; i < bmp->w ; i++ ) /* leave out padding */
				{
					p = &bmp->palette[ 4 * ( (unsigned int)tmpbuf[i]) ];
					buffer[3*(starty*bmp->w + i)  ] = ((short)p[2])<<DIFF_SHIFT;
					buffer[3*(starty*bmp->w + i)+1] = ((short)p[1])<<DIFF_SHIFT;
					buffer[3*(starty*bmp->w + i)+2] = ((short)p[0])<<DIFF_SHIFT;
				}
				starty += stepy;
			}
			break;
		case 16: /* RGB 555 */
			nx = (bmp->w + 1) & (~1); /* round up to multiple of 4 bytes per line */
			while( stopy-- )
			{
				fread( tmpbuf, 2, nx, bmp->infile );
				for( i=0 ; i < bmp->w ; i++ ) /* leave out padding */
				{
					b = (int)tmpbuf[ 2*i   ] + ( ((int)tmpbuf[ 2*i+1 ])<<8 );
					buffer[3*(starty*bmp->w + i)+2] = (b&0x1f)<<(3+DIFF_SHIFT);
					buffer[3*(starty*bmp->w + i)+1] = ((b>>5)&0x1f)<<(3+DIFF_SHIFT);
					buffer[3*(starty*bmp->w + i)  ] = ((b>>10)&0x1f)<<(3+DIFF_SHIFT);
				}
				starty += stepy;
			}
			break;
		case 24: /* BGR24 */
			nx = (bmp->w*3 + 3) & (~3); /* round up to multiple of 4 bytes per line */
			while( stopy-- )
			{
				fread( tmpbuf, 1, nx, bmp->infile );
				for( i=0 ; i < bmp->w ; i++ ) /* leave out padding */
				{
					buffer[3*(starty*bmp->w + i)  ] = ((short)tmpbuf[i*3+2])<<DIFF_SHIFT;
					buffer[3*(starty*bmp->w + i)+1] = ((short)tmpbuf[i*3+1])<<DIFF_SHIFT;
					buffer[3*(starty*bmp->w + i)+2] = ((short)tmpbuf[i*3  ])<<DIFF_SHIFT;
				}
				starty += stepy;
			}
			break;
		case 32:
			nx = bmp->w;
			while( stopy-- )
			{
				fread( tmpbuf, 4, nx, bmp->infile );
				for( i=0 ; i < bmp->w ; i++ ) 
				{
					buffer[3*(starty*bmp->w + i)  ] = ((short)tmpbuf[i*4+2])<<DIFF_SHIFT;
					buffer[3*(starty*bmp->w + i)+1] = ((short)tmpbuf[i*4+1])<<DIFF_SHIFT;
					buffer[3*(starty*bmp->w + i)+2] = ((short)tmpbuf[i*4  ])<<DIFF_SHIFT;
				}
				starty += stepy;
			}
			break;
		default:
			printf("sorry, depth %d not supported yet.\n",bmp->depth);
			err = -3;
			goto bailout;
			break;
	}
	err = 1; /* no error */
bailout:
	free( tmpbuf );
	return err;
}

void BMP_Close( struct bmpparse *bmp )
{
	if( bmp->magic != 0xDEADBEF )
		return;
	if( bmp->palette )
		free(bmp->palette );
	bmp->palette = NULL;
	bmp->infile  = NULL;
}

/*---------------- read one ASCII line and reject comment lines ----------------*/
int readline(FILE *infile, char * string)
{
 int aha,i;
 char t,*str;

 do
 {
  str = string;
  aha=1;
  i = 0;

  do
   {
    t = fgetc(infile);
    *str++ = t;

    if( t == '#' )
     aha=0;

    i++;
   }
  while( (i<200) && (t != '\n') && (t != EOF) );

  *(str-1) = 0;
 }
 while( (aha == 0) && (i<200) );

 if(i >= 200)
  aha = 0;

 return(aha);
}


/*------------------------main loop-----------------------------------------------*/
int main( int argc, char* argv[] )
{
 FILE *in=(0),*out=(0);
 char stringbuf[200];
 long w,h,t,dither=0;
 int mode,tmp,indexed=0;
 struct bmpparse bmpstr;

 /* poor man's parameter parsing */
 stringbuf[0]=0x7f;
 stringbuf[1]=0x7f;
 for( tmp=1 ; tmp < argc ; tmp++ )
 {
	if( strncmp( argv[tmp], "-flcm", strlen( "-flcm" ) ) == 0 )
	{
		flcm=1;
		continue;
	}
	if( strncmp( argv[tmp], "-indexed", strlen( "-indexed" ) ) == 0 )
	{
		indexed=1;
		continue;
	}
	if( strncmp( argv[tmp], "-dither", strlen( "-dither" ) ) == 0 )
	{
		dither = *(argv[tmp+1]) - '0';
		tmp++;
	}
	else
	{
	   if( stringbuf[0] == 0x7f )
	   {
		stringbuf[0] = tmp;
	   }
	   else
	   {
	 	if( stringbuf[1] == 0x7f )
	 	{
			stringbuf[1] = tmp;
		}
	   }
	}
 }

 if( stringbuf[1] == 0x7f )
 {
		printf("usage: %s [-dither n] [-indexed] [-flcm] infile.pnm outfile.c\n"\
		       "where dithering is optional and supports the modes\n" 
		       "0 = none\n"
		       "1 = Floyd-Steinberg\n"
		       "2 = Burkes\n"
		       "3 = Atkinson\n"
		       "4 = Ordered 2x2\n"
		       "5 = Ordered 4x4\n"
		       "-indexed means: load indexed file (BMP) and output\n"
		       "                color table and 8 Bit pixmap\n"
		       "-flcm means: convert first line to a colormap\n"
		       ,argv[0] );
		exit(0);
 }

 in =  fopen( argv[(int)stringbuf[0]], "rb" );
 if( in == NULL )
 {
	printf("cannot open input file %s\n", argv[1] );
	exit(0);
 }

 out = fopen( argv[(int)stringbuf[1]], "wb" );
 if( out == NULL )
 {
	printf("cannot open output file %s\n", argv[2] );
	fclose( in );
	exit(0);
 }

 mode = 0;
// readline(in,stringbuf);
 fread(stringbuf,1,2,in);
 stringbuf[2]=0;
 if( 0 != strncmp( stringbuf, "P6",2 ) )
 {
	if( 0 == strncmp( stringbuf, "P5",2 ) )
	{
			mode = 1;
	}
	else
	{
	 	if( 0 != strncmp( stringbuf, "P4",2 ) )
		{
			if( 0 != strncmp( stringbuf, "BM",2))
			{
				BAILOUT("Sorry, not 1/8/24 bit binary pnm (P4/P5/P6)\n");
			}
			else
				mode = 3;
		}
		else
			mode = 2;
 	}
 }
 if( mode < 3 )
 {
	readline(in,stringbuf+3); /* swallow newline for PNM */
	 /* check if all arguments in one line */
	 if( 4 != sscanf( stringbuf, "P%1d %ld %ld %ld",&tmp,&w,&h,&t ) )
	 {
	  readline(in,stringbuf);
	  if( 1 == sscanf(stringbuf,"%ld %ld",&w,&h)) /* 1 or 2 words in line ? */
	  {
	    if( readline(in,stringbuf) )     /* if 1 in last line, fetch next line */
	     sscanf(stringbuf,"%ld",&h);
	  }

	  readline(in,stringbuf);	     /* result: 255 */
	 }
 }
 else
 {
 	/* parse BMP header */
	if( BMP_Parse( in, &bmpstr ) <= 0 ) /* BMP mode might be 1,4,... corresponding to 1,4,8,16,24,32 bit  */
	{
		BAILOUT("looks like BMP but cannot be parsed here, sorry.\n");
	}
	w = bmpstr.w;
	h = bmpstr.h;
 }

 printf("w is %ld, h is %ld mode is %d dither %ld\n",w,h,mode,dither);
// if( w&1 ) /* disabled warning: never encountered practical issues, so don't bother */
// {
//  printf("width is not a multiple of 2, check for problems in 12 bit mode\n");
// }

// fprintf( out, "unsigned int tex_w=%ld;\n",w);
// fprintf( out, "unsigned int tex_h=%ld;\n\n",w);
// fprintf( out, "unsigned char tex_data[] = {\n");

 {
  unsigned char a,b;
  int  i,max,j;
  short *buf,*bptr;
  unsigned char b1[3]; /* RGB buffer */
 
  max = w*h;
  buf = (short*)malloc( 3*w*(h+1)*sizeof(short) ) ; /* 3 byte per pixel, sufficient space for zero-padding */
  if( !buf )
  {
  	BAILOUT("Cannot allocate memory buffer\n");
  }
  memset( buf, 0, 3*w*(h+1)*sizeof(short) );

  /* read file, convert to RGB as shorts per pixel and shift left */
  switch(mode)
  {
	case 0:
		/* RGB */
		bptr=buf;
		for( i=0 ; i<max; i++ )
		{
			fread( b1, 1, 3, in );
			*bptr++=b1[0]<<DIFF_SHIFT;
			*bptr++=b1[1]<<DIFF_SHIFT;
			*bptr++=b1[2]<<DIFF_SHIFT;
		}

		break;
	case 1: 
		/* Gray */
		bptr=buf;
		for( i=0 ; i<max; i++ )
		{
			fread( b1, 1, 1, in );
			*bptr++=b1[0]<<DIFF_SHIFT;
			*bptr++=b1[0]<<DIFF_SHIFT;
			*bptr++=b1[0]<<DIFF_SHIFT;
		}
		break;
	case 2: 
		/* Bitmap (converted to 24 bit RGB) */
	 	max = (max+7)/8; /* round up to n*8 Bits */
		bptr= buf;
		for( i = 0 ; i < max ; i++ )
	  	{
			fread( &a, 1, 1, in );
			for( j = 128; j != 0 ; j >>= 1 )
			{
				b=(a&j) ? 255 : 0;
				*bptr++ = b<<DIFF_SHIFT;
				*bptr++ = b<<DIFF_SHIFT;
				*bptr++ = b<<DIFF_SHIFT;
			}
		}
		break;
	case 3:
		/* BMP file, converted to 24 Bit RGB */
		BMP_GetPix( &bmpstr, buf, 3*w*(h+1), 1 );
		break;
	default:
		printf("Error: wrong internal mode, this shouldn't have happened...\n");
		break;
  }

  if( indexed )
  {
	if( mode != 3 )
		BAILOUT("Sorry, no PNM support for indexed graphics\n");
	if( bmpstr.depth > 8 )
		BAILOUT("Sorry, truecolor BMP is not supported for indexed graphics, use 8 Bit BMP!\n");
	
	 img2siemens( buf, w, h, dither, out, bmpstr.palette,bmpstr.ncolors ); /* palette is BGRA 32 Bit */
  }
  else
  {
   /* now write the output file */
   img2siemens( buf, w, h, dither, out, NULL,0 );
  }

  free(buf);
 }

 fclose(in);
 fclose(out);

 return 0;
}


